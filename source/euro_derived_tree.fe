// FE program as example for an EURO derived datafile tree
//
 
global initialized;

// Initialization part: loading conversion currencies
if (!initialized){
  initialized = 1;

  version = 1700011;
  
  tree_option = "TREEID=UIHIST";
 
  in_currency = ["NLG", "DEM"];
  in_currency_ados = ["SPO_XEUNLG", "SPO_XEUDEM"];
  in_currency_introduction_dates = [19980611, 19980611];

  in_currency_TS = seq(j = 0; j < len(in_currency); ++j) ts(in_currency_ados[j], [19800101, dayplus(in_currency_introduction_dates[j], -1)], [0, 10], ["SCALE_DAY", tree_option]);

  use_cache = 1;
  // do not use cache if older than 3600 seconds:
  max_time_lag = 3600;
  // do not use cache if time passed one of the recomputation times
  times_to_recompute = [ 0, 70000, 102200, 120000, 170000 ];
}


ado = $SYMBOL;

if (use_cache){
  cache_name = "EURO." + ado;
  TS = cache_read(cache_name);
  // Cache looks like: $SYMBOL, version, last_compute_date, last_compute_time, fields, TS
  cache_time = $TIMETODAY;
  cache_date = $TODAY;
  if ((len(TS) == 6) && (TS[0] == ado) && (TS[1] == version) && (timediff(TS[3], cache_time) < max_time_lag) && (TS[2] == cache_date)){
    // check whether recompute anyway
    i = le_lsearch(times_to_recompute, cache_time);
    if (TS[3] >= times_to_recompute[i]){
      // print("Using cache for " + ado + " at " + str(cache_time));
      __fields__ = TS[4];
      return(TS[5]);
    }
  }
}

TS = ts(ado, tree_option);
__fields__ = TS[0][8];

TS = ts(ado, [250,0], $FIELDS, tree_option);

// retrieve instrument type and 'old' currency!
A = attribute(ado, ["INSTYP", "ISOCUR"]);
instyp = A[0];
currency = A[1];

if (!is_string(instyp) && !is_string(currency)){
  //print("No INSTYP and ISOCUR attribute for " + ado);
} else {
  //if (!is_string(instyp))
  //  print("No INSTYP attribute for " + ado);
  //if (!is_string(currency))
  //  print("No ISOCUR attribute for " + ado);
}

// only apply for shares! 
if (instyp == "SHARE"){

  if (!is_string(currency)){
    print("No ISOCUR attribute for share " + ado + " while computing derived TS for tree " + $TREEID);
    return([]);
  }

  in_index = lsearch(in_currency, currency);
  if (in_index >= 0){
    cfactor = last(in_currency_TS[in_index][1]);
    introduction_date = in_currency_introduction_dates[in_index];
    dates = TS[0];
    if (first(dates) < introduction_date){

      len_dates = len(dates);
      i = ge_lsearch(dates, introduction_date);
      if (!(i >= 0))
        i = len_dates;
 
      if (1){ /* apply time series ! */
        dates_TS = in_currency_TS[in_index][0];
        factors_TS = in_currency_TS[in_index][1];
        correction_factors = list(len_dates);
        dates_TS_index = ge_lsearch(dates_TS, dates[0]);
        if (dates_TS[dates_TS_index] > dates[0])
          dates_TS_index--;
        if (!(dates_TS_index > 0))
          dates_TS_index = 0;
        cfactor = factors_TS[dates_TS_index];

        for (j = 0; j < i; ++j){
          while (dates_TS[dates_TS_index+1] <= dates[j]){
            dates_TS_index++;
            cfactor = factors_TS[dates_TS_index];
          }
          correction_factors[j] = cfactor;
        }
        for (; j < len_dates; ++j)
          correction_factors[j] = 1; 
      }
      else 
        correction_factors = seq(j = 0; j < len_dates; ++j) (j < i) ? cfactor : 1;  
 
      for (j = 0; j < len(TS); ++j){
        x = first(TS[j]);
        if (is_na(x))
          x = first(strip(TS[j]));
        if (is_float(x))
          TS[j] = map(/, TS[j], correction_factors);
      }
    }
  }
}

if (use_cache){
  if (!cache_write(cache_name, [ado, version, cache_date, cache_time, $FIELDS, TS]))
    print("Could not write cache for " + ado);
}

return(TS);
                   
                                                                                                        
